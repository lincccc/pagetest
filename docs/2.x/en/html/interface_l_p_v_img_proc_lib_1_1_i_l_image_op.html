<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LPV: ILImageOp Interface Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="tutorial-utils.js"></script>
<script type="text/javascript" src="version.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="lpv_stylesheet.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 100px;">
  <td id="projectlogo" style="padding-left: 1em; text-align: center; vertical-align: middle;"><a href="index.html"><img alt="Logo" src="lpv_logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em; vertical-align: bottom; padding-bottom: 5px;">
   <div id="projectbrief">Leaper Vision Toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_l_p_v_img_proc_lib.html">LPVImgProcLib</a></li><li class="navelem"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html">ILImageOp</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#properties">Properties</a>  </div>
  <div class="headertitle">
<div class="title">ILImageOp Interface Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This interface provide functionalities of basic and advanced image operations, such as resizing, rotation, arithmetic, blending, tiling, etc.  
 <a href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for ILImageOp:</div>
<div class="dyncontent">
 <div class="center">
  <img src="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.png" usemap="#ILImageOp_map" alt=""/>
  <map id="ILImageOp_map" name="ILImageOp_map">
<area href="interface_l_p_v_core_lib_1_1_i_l_object.html" title="This base interface for a serializable LPV object." alt="ILObject" shape="rect" coords="0,0,72,24"/>
<area href="class_l_p_v_img_proc_lib_1_1_l_image_op.html" alt="LImageOp" shape="rect" coords="0,112,72,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3e5def54f8136e79315f20cc80992cdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a3e5def54f8136e79315f20cc80992cdf">Add</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img1, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img2, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result)</td></tr>
<tr class="separator:a3e5def54f8136e79315f20cc80992cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7af1f45aa910f16da36f7b31fae6af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a6e7af1f45aa910f16da36f7b31fae6af">AddScalar</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img, double scalar, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result, double scalar2, double scalar3)</td></tr>
<tr class="separator:a6e7af1f45aa910f16da36f7b31fae6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17bc3e2a9a5ba1e1532f5e930039970"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#ab17bc3e2a9a5ba1e1532f5e930039970">AddWeighted</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img1, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img2, double alpha, double beta, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result)</td></tr>
<tr class="separator:ab17bc3e2a9a5ba1e1532f5e930039970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae032234dba522c2cfd59801c6aaedc01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#ae032234dba522c2cfd59801c6aaedc01">BitAnd</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img1, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img2, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result)</td></tr>
<tr class="separator:ae032234dba522c2cfd59801c6aaedc01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671c60c7761ad45fc101e444f5aad851"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a671c60c7761ad45fc101e444f5aad851">BitAndScalar</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img, double scalar, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result, double scalar2, double scalar3)</td></tr>
<tr class="separator:a671c60c7761ad45fc101e444f5aad851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd391126a76472eca8379e53cdf4e59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a5dd391126a76472eca8379e53cdf4e59">BitNot</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img1, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result)</td></tr>
<tr class="separator:a5dd391126a76472eca8379e53cdf4e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8d2d7d116274b3c2231b4ef71fb7ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#aec8d2d7d116274b3c2231b4ef71fb7ba">BitOr</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img1, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img2, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result)</td></tr>
<tr class="separator:aec8d2d7d116274b3c2231b4ef71fb7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1ae39c4d0f8653e34c78f4ee461e3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a7e1ae39c4d0f8653e34c78f4ee461e3a">BitOrScalar</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img, double scalar, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result, double scalar2, double scalar3)</td></tr>
<tr class="separator:a7e1ae39c4d0f8653e34c78f4ee461e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c138b11e25395a41672b921e9dc529"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#ab8c138b11e25395a41672b921e9dc529">BitXor</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img1, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img2, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result)</td></tr>
<tr class="separator:ab8c138b11e25395a41672b921e9dc529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa18ce12820a75fb74f6b1ce01c47ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a9fa18ce12820a75fb74f6b1ce01c47ae">BitXorScalar</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img, double scalar, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result, double scalar2, double scalar3)</td></tr>
<tr class="separator:a9fa18ce12820a75fb74f6b1ce01c47ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe14eacf1d5bc838d521a82f1ce0b6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#acfe14eacf1d5bc838d521a82f1ce0b6a">Blend</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image_list.html">ILImageList</a> *imgList, <a class="el" href="namespace_l_p_v_core_lib.html#a044b4c1019ab24bd62eed3e7fd764b85">LPVAggregation</a> aggType, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result)</td></tr>
<tr class="separator:acfe14eacf1d5bc838d521a82f1ce0b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ce706b860d77991b5447d74ab7a6ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a94ce706b860d77991b5447d74ab7a6ca">Diff</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img1, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img2, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result)</td></tr>
<tr class="separator:a94ce706b860d77991b5447d74ab7a6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882103f487fab90873697dcecc268dc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a882103f487fab90873697dcecc268dc8">DiffScalar</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img, double scalar, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result, double scalar2, double scalar3)</td></tr>
<tr class="separator:a882103f487fab90873697dcecc268dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a28d791687c074c41b9c44d43bf858"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#aa0a28d791687c074c41b9c44d43bf858">Divide</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img1, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img2, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result)</td></tr>
<tr class="separator:aa0a28d791687c074c41b9c44d43bf858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0b00c0d95d6355548d08f5725b3656"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#adb0b00c0d95d6355548d08f5725b3656">DivideScalar</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img, double scalar, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result, double scalar2, double scalar3)</td></tr>
<tr class="separator:adb0b00c0d95d6355548d08f5725b3656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69163617efcc3e863d467bc147af34e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a69163617efcc3e863d467bc147af34e4">Flip</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img, <a class="el" href="namespace_l_p_v_core_lib.html#aca29028958a911e3c81e54458680682f">LPVFlipType</a> flipType, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result)</td></tr>
<tr class="separator:a69163617efcc3e863d467bc147af34e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2fdb50ded7f6231c8a2cf2a655bb66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a9e2fdb50ded7f6231c8a2cf2a655bb66">GainOffset</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result, double gain, double offset)</td></tr>
<tr class="separator:a9e2fdb50ded7f6231c8a2cf2a655bb66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009217aa93d3f41dfdf5a3c070264aab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a009217aa93d3f41dfdf5a3c070264aab">Invert</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result)</td></tr>
<tr class="separator:a009217aa93d3f41dfdf5a3c070264aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fb50f951e9df17d7243b6e7db56a9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a09fb50f951e9df17d7243b6e7db56a9c">Log</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img, double base, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result)</td></tr>
<tr class="separator:a09fb50f951e9df17d7243b6e7db56a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c79b8eb70dff2f1169d0a06db7bad1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#ae7c79b8eb70dff2f1169d0a06db7bad1">Max</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img1, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img2, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result)</td></tr>
<tr class="separator:ae7c79b8eb70dff2f1169d0a06db7bad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fbc595b7b5936b45263e9ae1e1cef6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a41fbc595b7b5936b45263e9ae1e1cef6">MaxScalar</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img, double scalar, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result, double scalar2, double scalar3)</td></tr>
<tr class="separator:a41fbc595b7b5936b45263e9ae1e1cef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca3e1de386b0ff5fb6fad7fd3a54d2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#afca3e1de386b0ff5fb6fad7fd3a54d2d">Min</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img1, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img2, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result)</td></tr>
<tr class="separator:afca3e1de386b0ff5fb6fad7fd3a54d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62830872fac430e8737587ca026557d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a62830872fac430e8737587ca026557d2">MinScalar</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img, double scalar, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result, double scalar2, double scalar3)</td></tr>
<tr class="separator:a62830872fac430e8737587ca026557d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24a05c09037b92bf79e964ac8118c56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#aa24a05c09037b92bf79e964ac8118c56">Multiply</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img1, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img2, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result)</td></tr>
<tr class="separator:aa24a05c09037b92bf79e964ac8118c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1b15c7aadd849832317e466164e5fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a9c1b15c7aadd849832317e466164e5fc">MultiplyScalar</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img, double scalar, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result, double scalar2, double scalar3)</td></tr>
<tr class="separator:a9c1b15c7aadd849832317e466164e5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf660a10ca16161030619866f2b49e55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#adf660a10ca16161030619866f2b49e55">Normalize</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *resultImg, double fromMinValue, double fromMaxValue, double toMinValue, double toMaxValue, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *belowMask, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *aboveMask)</td></tr>
<tr class="separator:adf660a10ca16161030619866f2b49e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2263e543b518236ba5126bb4888e2b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#aa2263e543b518236ba5126bb4888e2b0">NormalizeMeanStdDev</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *resultImg, double k1, double k2, double toMinValue, double toMaxValue, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *belowMask, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *aboveMask)</td></tr>
<tr class="separator:aa2263e543b518236ba5126bb4888e2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51684082a5ca31d6db24aba6be294b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#af51684082a5ca31d6db24aba6be294b3">Pow</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img, double power, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result)</td></tr>
<tr class="separator:af51684082a5ca31d6db24aba6be294b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1501a3fbcf6b7f741134d9af0ceef9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_array.html">LArray</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#afc1501a3fbcf6b7f741134d9af0ceef9">ProjectX</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img, <a class="el" href="namespace_l_p_v_core_lib.html#a044b4c1019ab24bd62eed3e7fd764b85">LPVAggregation</a> aggType)</td></tr>
<tr class="separator:afc1501a3fbcf6b7f741134d9af0ceef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af52d9cf013941f00b02e54831c8dec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_array.html">LArray</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a8af52d9cf013941f00b02e54831c8dec">ProjectY</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img, <a class="el" href="namespace_l_p_v_core_lib.html#a044b4c1019ab24bd62eed3e7fd764b85">LPVAggregation</a> aggType)</td></tr>
<tr class="separator:a8af52d9cf013941f00b02e54831c8dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b035d4123952719d670e3f9072029b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a2b035d4123952719d670e3f9072029b8">Resize</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img, double zoomX, double zoomY, <a class="el" href="namespace_l_p_v_core_lib.html#a8994f6c3a4ba4e0d0e9a8eb78ac86c92">LPVInterpolationMethod</a> interMethod, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result)</td></tr>
<tr class="separator:a2b035d4123952719d670e3f9072029b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d23a653d5816ffbb6089950840fa5c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a3d23a653d5816ffbb6089950840fa5c5">ResizeTo</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img, int w, int h, <a class="el" href="namespace_l_p_v_core_lib.html#a8994f6c3a4ba4e0d0e9a8eb78ac86c92">LPVInterpolationMethod</a> interMethod, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result)</td></tr>
<tr class="separator:a3d23a653d5816ffbb6089950840fa5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2cd12aabad596e032548b18af31928"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a5a2cd12aabad596e032548b18af31928">Rotate</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img, double angle, <a class="el" href="namespace_l_p_v_core_lib.html#a8994f6c3a4ba4e0d0e9a8eb78ac86c92">LPVInterpolationMethod</a> interMethod, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result)</td></tr>
<tr class="separator:a5a2cd12aabad596e032548b18af31928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63734a869140124d46e534ec5fbadde3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a63734a869140124d46e534ec5fbadde3">ScaleRotate</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img, double angle, double zoomX, double zoomY, double pivotImgX, double pivotImgY, double pivotResultX, double pivotResultY, <a class="el" href="namespace_l_p_v_core_lib.html#a8994f6c3a4ba4e0d0e9a8eb78ac86c92">LPVInterpolationMethod</a> interMethod, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result)</td></tr>
<tr class="separator:a63734a869140124d46e534ec5fbadde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafee0b4602b5dea5c473185cd2976be3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#aafee0b4602b5dea5c473185cd2976be3">Split</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img, int xCount, int xStep, int xSpace, int yCount, int yStep, int ySpace, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image_list.html">ILImageList</a> *resultList, BOOL cyclicMode, BOOL sameSize)</td></tr>
<tr class="separator:aafee0b4602b5dea5c473185cd2976be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ea99043d2749a8f013eb7d92583fd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#ad8ea99043d2749a8f013eb7d92583fd6">SplitX</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img, int count, int step, int space, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image_list.html">ILImageList</a> *resultList, BOOL cyclicMode, BOOL sameSize)</td></tr>
<tr class="separator:ad8ea99043d2749a8f013eb7d92583fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d94a20c6f7bef41956747a5c3c6a04e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a0d94a20c6f7bef41956747a5c3c6a04e">SplitY</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img, int count, int step, int space, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image_list.html">ILImageList</a> *resultList, BOOL cyclicMode, BOOL sameSize)</td></tr>
<tr class="separator:a0d94a20c6f7bef41956747a5c3c6a04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa20ebb5264ac83616ce57a100a7da0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a6aa20ebb5264ac83616ce57a100a7da0">Sub</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img1, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img2, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result)</td></tr>
<tr class="separator:a6aa20ebb5264ac83616ce57a100a7da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb349dc5aeaadaacfcefde3fb283eaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a4bb349dc5aeaadaacfcefde3fb283eaf">SubScalar</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img, double scalar, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result, double scalar2, double scalar3)</td></tr>
<tr class="separator:a4bb349dc5aeaadaacfcefde3fb283eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102798855741d439b8903234884713a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a102798855741d439b8903234884713a8">TileX</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image_list.html">ILImageList</a> *imgList, int columnCount, BOOL compactMode, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result)</td></tr>
<tr class="separator:a102798855741d439b8903234884713a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee13ea45a863b3805c6d711be3b9672"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a4ee13ea45a863b3805c6d711be3b9672">TileY</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image_list.html">ILImageList</a> *imgList, int rowCount, BOOL compactMode, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result)</td></tr>
<tr class="separator:a4ee13ea45a863b3805c6d711be3b9672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f47cc18862bd892bae73e722c9443d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a1f47cc18862bd892bae73e722c9443d4">Transform</a> (<a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *img, <a class="el" href="interface_l_p_v_geom_lib_1_1_i_l_transform.html">ILTransform</a> *tf, <a class="el" href="namespace_l_p_v_core_lib.html#a8994f6c3a4ba4e0d0e9a8eb78ac86c92">LPVInterpolationMethod</a> interMethod, <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *result)</td></tr>
<tr class="separator:a1f47cc18862bd892bae73e722c9443d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_interface_l_p_v_core_lib_1_1_i_l_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_interface_l_p_v_core_lib_1_1_i_l_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="interface_l_p_v_core_lib_1_1_i_l_object.html">ILObject</a></td></tr>
<tr class="memitem:aa7dcddf685e0ba4ddc2d84b0d191f3d7 inherit pub_methods_interface_l_p_v_core_lib_1_1_i_l_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_object.html">ILObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_object.html#aa7dcddf685e0ba4ddc2d84b0d191f3d7">Copy</a> ()</td></tr>
<tr class="separator:aa7dcddf685e0ba4ddc2d84b0d191f3d7 inherit pub_methods_interface_l_p_v_core_lib_1_1_i_l_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74069eb14437a9a889322b62e52db75f inherit pub_methods_interface_l_p_v_core_lib_1_1_i_l_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_l_p_v_core_lib.html#a753df57c2ab9773ee9dff5747163ee4a">LPVErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_object.html#a74069eb14437a9a889322b62e52db75f">Load</a> (<a class="el" href="class_l_string.html">LString</a> filename)</td></tr>
<tr class="separator:a74069eb14437a9a889322b62e52db75f inherit pub_methods_interface_l_p_v_core_lib_1_1_i_l_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372de693ad40b3f42839c8ec6ac845f4 inherit pub_methods_interface_l_p_v_core_lib_1_1_i_l_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_object.html#a372de693ad40b3f42839c8ec6ac845f4">Reset</a> ()</td></tr>
<tr class="separator:a372de693ad40b3f42839c8ec6ac845f4 inherit pub_methods_interface_l_p_v_core_lib_1_1_i_l_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b6e3ad558d350e70a837c28554acf4 inherit pub_methods_interface_l_p_v_core_lib_1_1_i_l_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_l_p_v_core_lib.html#a753df57c2ab9773ee9dff5747163ee4a">LPVErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_object.html#a86b6e3ad558d350e70a837c28554acf4">Save</a> (<a class="el" href="class_l_string.html">LString</a> filename)</td></tr>
<tr class="separator:a86b6e3ad558d350e70a837c28554acf4 inherit pub_methods_interface_l_p_v_core_lib_1_1_i_l_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a489f4ba37f2dfee6500e8ff54d3c3 inherit pub_methods_interface_l_p_v_core_lib_1_1_i_l_object"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_object.html#a73a489f4ba37f2dfee6500e8ff54d3c3">Valid</a> ()</td></tr>
<tr class="separator:a73a489f4ba37f2dfee6500e8ff54d3c3 inherit pub_methods_interface_l_p_v_core_lib_1_1_i_l_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a2e7696fb1229d15ab0022bafe882b69f"><td class="memItemLeft" align="right" valign="top"><a id="a2e7696fb1229d15ab0022bafe882b69f"></a>
<a class="el" href="struct_l_p_v_core_lib_1_1_l_color.html">LColor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a2e7696fb1229d15ab0022bafe882b69f">BGColor</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a2e7696fb1229d15ab0022bafe882b69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The background color, used to fill the uncovered part in operation such as <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a5a2cd12aabad596e032548b18af31928">Rotate()</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a102798855741d439b8903234884713a8">TileX()</a>. By default, it's black. <br /></td></tr>
<tr class="separator:a2e7696fb1229d15ab0022bafe882b69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac665151de36f62491cbc143500cac3cd"><td class="memItemLeft" align="right" valign="top"><a id="ac665151de36f62491cbc143500cac3cd"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#ac665151de36f62491cbc143500cac3cd">ResultGain</a><code> [get, set]</code></td></tr>
<tr class="memdesc:ac665151de36f62491cbc143500cac3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale the final result of the operation with the gain value. It should be a non-zero value, by default, it's 1, aka no scale. <br /></td></tr>
<tr class="separator:ac665151de36f62491cbc143500cac3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89fd99d76e4f617802fdffabe63ef9a"><td class="memItemLeft" align="right" valign="top"><a id="aa89fd99d76e4f617802fdffabe63ef9a"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#aa89fd99d76e4f617802fdffabe63ef9a">ResultOffset</a><code> [get, set]</code></td></tr>
<tr class="memdesc:aa89fd99d76e4f617802fdffabe63ef9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The offset value added to the final result of the operation, after scaled by <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#ac665151de36f62491cbc143500cac3cd" title="Scale the final result of the operation with the gain value. It should be a non-zero value,...">ResultGain</a>. Default to 0, aka no offset. <br /></td></tr>
<tr class="separator:aa89fd99d76e4f617802fdffabe63ef9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This interface provide functionalities of basic and advanced image operations, such as resizing, rotation, arithmetic, blending, tiling, etc. </p>
<p>To use this interface, you should create a <a class="el" href="class_l_p_v_img_proc_lib_1_1_l_image_op.html">LImageOp</a> object.</p>
<h3>Example Code </h3>
 <div class='newInnerHTML' title='cpp' style='display: none;'>C++</div><div class='toggleable_div label_cpp' style='display: none;'><div class="fragment"><div class="line">ILImageOpPtr imgOp = LImageOp::Create();</div>
<div class="line"><span class="comment">// resultImg = img * 1.1 + 20</span></div>
<div class="line">imgOp-&gt;GainOffset(img, resultImg, 1.1, 20);</div>
<div class="line"><span class="comment">// resultImg = avg(imgList)</span></div>
<div class="line">imgOp-&gt;Blend(imgList, LPVAggregation::LPVAggAvg, resultImg);</div>
</div><!-- fragment --> </div>  <div class='newInnerHTML' title='csharp' style='display: none;'>C#</div><div class='toggleable_div label_csharp' style='display: none;'><div class="fragment"><div class="line">LImageOp imgOp = <span class="keyword">new</span> LImageOp();</div>
<div class="line"><span class="comment">// resultImg = img * 1.1 + 20</span></div>
<div class="line">imgOp.GainOffset(img, resultImg, 1.1, 20);</div>
<div class="line"><span class="comment">// resultImg = avg(imgList)</span></div>
<div class="line">imgOp.Blend(imgList, LPVAggregation::LPVAggAvg, resultImg);</div>
</div><!-- fragment --> </div>  <div class='newInnerHTML' title='com' style='display: none;'>COM</div><div class='toggleable_div label_com' style='display: none;'><div class="fragment"><div class="line">ILImageOpPtr imgOp = LImageOp::Create();</div>
<div class="line"><span class="comment">// or, ILImageOpPtr imgOp(__uuidof(LImageOp)), for absence of built-in Create functions (before 2.2.0)</span></div>
<div class="line"><span class="comment">// resultImg = img * 1.1 + 20</span></div>
<div class="line">imgOp-&gt;GainOffset(img, resultImg, 1.1, 20);</div>
<div class="line"><span class="comment">// resultImg = avg(imgList)</span></div>
<div class="line">imgOp-&gt;Blend(imgList, LPVAggregation::LPVAggAvg, resultImg);</div>
</div><!-- fragment --> </div>  </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a3e5def54f8136e79315f20cc80992cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e5def54f8136e79315f20cc80992cdf">&#9670;&nbsp;</a></span>Add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the two input images pixel by pixel, output a new result image \( I&#39; = I_{1} + I_{2} \) . \nThe two input image should have the same size and format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img1</td><td>The first input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">img2</td><td>The second input image </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a6e7af1f45aa910f16da36f7b31fae6af">AddScalar()</a> </dd></dl>

</div>
</div>
<a id="a6e7af1f45aa910f16da36f7b31fae6af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e7af1f45aa910f16da36f7b31fae6af">&#9670;&nbsp;</a></span>AddScalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddScalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the input images and a scalar value pixel by pixel, output a new result image \( I&#39; = I + s \) . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>The input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td>The input scalar </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar2</td><td>For a color image to specify the scalar value used for the 2nd channel<br  />
If both <em>scalar2</em> and <em>scalar3</em> is set to 0 (default), we'll use the value <em>scalar</em> for all 3 channels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar3</td><td>For a color image to specify the scalar value used for the 3rd channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a3e5def54f8136e79315f20cc80992cdf">Add()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.8.0 </dd></dl>

</div>
</div>
<a id="ab17bc3e2a9a5ba1e1532f5e930039970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17bc3e2a9a5ba1e1532f5e930039970">&#9670;&nbsp;</a></span>AddWeighted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddWeighted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the two input images pixel by pixel, output a new result image, \( I&#39; = I_{1} * alpha + I_{2} * beta \) . The two input image should have the same size and format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img1</td><td>The first input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">img2</td><td>The second input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>The weight of the first input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>The weight of the second input image </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae032234dba522c2cfd59801c6aaedc01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae032234dba522c2cfd59801c6aaedc01">&#9670;&nbsp;</a></span>BitAnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BitAnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the bit-wise conjunction of the two input images pixel by pixel, output a new result image \( I&#39; = I_{1} \land I_{2} \) . \nThe two input image should have the same size and format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img1</td><td>The first input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">img2</td><td>The second input image </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a671c60c7761ad45fc101e444f5aad851">BitAndScalar()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.8.0 </dd></dl>

</div>
</div>
<a id="a671c60c7761ad45fc101e444f5aad851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a671c60c7761ad45fc101e444f5aad851">&#9670;&nbsp;</a></span>BitAndScalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BitAndScalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the bit-wise conjunction of the input images and a scalar value pixel by pixel, output a new result image \( I&#39; = I \land s \) . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>The input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td>The input scalar </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar2</td><td>For a color image to specify the scalar value used for the 2nd channel<br  />
If both <em>scalar2</em> and <em>scalar3</em> is set to 0 (default), we'll use the value <em>scalar</em> for all 3 channels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar3</td><td>For a color image to specify the scalar value used for the 3rd channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#ae032234dba522c2cfd59801c6aaedc01">BitAnd()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.8.0 </dd></dl>

</div>
</div>
<a id="a5dd391126a76472eca8379e53cdf4e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd391126a76472eca8379e53cdf4e59">&#9670;&nbsp;</a></span>BitNot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BitNot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the bit-wise inversion of the input images pixel by pixel, output a new result image \( I&#39; = \lnot I \) .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>The input image </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a009217aa93d3f41dfdf5a3c070264aab">Invert()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.8.0 </dd></dl>

</div>
</div>
<a id="aec8d2d7d116274b3c2231b4ef71fb7ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8d2d7d116274b3c2231b4ef71fb7ba">&#9670;&nbsp;</a></span>BitOr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BitOr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the bit-wise disjunction of the two input images pixel by pixel, output a new result image \( I&#39; = I_{1} \lor I_{2} \) . \nThe two input image should have the same size and format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img1</td><td>The first input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">img2</td><td>The second input image </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a7e1ae39c4d0f8653e34c78f4ee461e3a">BitOrScalar()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.8.0 </dd></dl>

</div>
</div>
<a id="a7e1ae39c4d0f8653e34c78f4ee461e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e1ae39c4d0f8653e34c78f4ee461e3a">&#9670;&nbsp;</a></span>BitOrScalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BitOrScalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the bit-wise disjunction of the input images and a scalar value pixel by pixel, output a new result image \( I&#39; = I \lor s \) . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>The input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td>The input scalar </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar2</td><td>For a color image to specify the scalar value used for the 2nd channel<br  />
If both <em>scalar2</em> and <em>scalar3</em> is set to 0 (default), we'll use the value <em>scalar</em> for all 3 channels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar3</td><td>For a color image to specify the scalar value used for the 3rd channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#aec8d2d7d116274b3c2231b4ef71fb7ba">BitOr()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.8.0 </dd></dl>

</div>
</div>
<a id="ab8c138b11e25395a41672b921e9dc529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c138b11e25395a41672b921e9dc529">&#9670;&nbsp;</a></span>BitXor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BitXor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the bit-wise "exclusive or" operation of the two input images pixel by pixel, output a new result image \( I&#39; = I_{1} \oplus I_{2} \) . \nThe two input image should have the same size and format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img1</td><td>The first input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">img2</td><td>The second input image </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a9fa18ce12820a75fb74f6b1ce01c47ae">BitXorScalar()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.8.0 </dd></dl>

</div>
</div>
<a id="a9fa18ce12820a75fb74f6b1ce01c47ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa18ce12820a75fb74f6b1ce01c47ae">&#9670;&nbsp;</a></span>BitXorScalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BitXorScalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the bit-wise "exclusive or" operation of the input images and a scalar value pixel by pixel, output a new result image \( I&#39; = I \oplus s \) . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>The input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td>The input scalar </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar2</td><td>For a color image to specify the scalar value used for the 2nd channel<br  />
If both <em>scalar2</em> and <em>scalar3</em> is set to 0 (default), we'll use the value <em>scalar</em> for all 3 channels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar3</td><td>For a color image to specify the scalar value used for the 3rd channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#ab8c138b11e25395a41672b921e9dc529">BitXor()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.8.0 </dd></dl>

</div>
</div>
<a id="acfe14eacf1d5bc838d521a82f1ce0b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe14eacf1d5bc838d521a82f1ce0b6a">&#9670;&nbsp;</a></span>Blend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Blend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image_list.html">ILImageList</a> *&#160;</td>
          <td class="paramname"><em>imgList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_l_p_v_core_lib.html#a044b4c1019ab24bd62eed3e7fd764b85">LPVAggregation</a>&#160;</td>
          <td class="paramname"><em>aggType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multi-frame image blending allows user to accumulate a number of acquired images of the same scene and generate one blending image. Different aggregation type may be used for different purposes.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Aggregation Type   </th><th class="markdownTableHeadNone">Usage    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Average   </td><td class="markdownTableBodyNone">Reduce image noise, generate a reliable image where lighting can be erratic.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Min   </td><td class="markdownTableBodyNone">Reduce light areas, for example, the overexposed parts.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Max   </td><td class="markdownTableBodyNone">Reduce shadows    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Standard deviation   </td><td class="markdownTableBodyNone">Lighter pixels indicate a higher degree of variation between images.   </td></tr>
</table>
<p><em>Note: other aggregation types are not supported.</em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">imgList</td><td>The input image list for blending. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aggType</td><td>The aggregation method used for blending. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Output the blending result.</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Example</dt>
<dd>ImageBlend.cpp/cs</dd>
</dl>

</div>
</div>
<a id="a94ce706b860d77991b5447d74ab7a6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ce706b860d77991b5447d74ab7a6ca">&#9670;&nbsp;</a></span>Diff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Diff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the difference of the two input images pixel by pixel, output a new result image \( I&#39; = abs(I_{1} - I_{2}) \) . \nThe two input image should have the same size and format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img1</td><td>The first input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">img2</td><td>The second input image </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a882103f487fab90873697dcecc268dc8">DiffScalar()</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a6aa20ebb5264ac83616ce57a100a7da0">Sub()</a> </dd></dl>

</div>
</div>
<a id="a882103f487fab90873697dcecc268dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a882103f487fab90873697dcecc268dc8">&#9670;&nbsp;</a></span>DiffScalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DiffScalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the difference of the input images and a scalar value pixel by pixel, output a new result image \( I&#39; = abs(I - s) \) . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>The input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td>The input scalar </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar2</td><td>For a color image to specify the scalar value used for the 2nd channel<br  />
If both <em>scalar2</em> and <em>scalar3</em> is set to 0 (default), we'll use the value <em>scalar</em> for all 3 channels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar3</td><td>For a color image to specify the scalar value used for the 3rd channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a94ce706b860d77991b5447d74ab7a6ca">Diff()</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a4bb349dc5aeaadaacfcefde3fb283eaf">SubScalar()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.8.0 </dd></dl>

</div>
</div>
<a id="aa0a28d791687c074c41b9c44d43bf858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a28d791687c074c41b9c44d43bf858">&#9670;&nbsp;</a></span>Divide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Divide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide the first input image by the second input image pixel by pixel, output a new result image \( I&#39; = I_{1} / I_{2} \) . \nThe two input image should have the same size and format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img1</td><td>The first input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">img2</td><td>The second input image </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#adb0b00c0d95d6355548d08f5725b3656">DivideScalar()</a> </dd></dl>

</div>
</div>
<a id="adb0b00c0d95d6355548d08f5725b3656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0b00c0d95d6355548d08f5725b3656">&#9670;&nbsp;</a></span>DivideScalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DivideScalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide the input image by a scalar value pixel by pixel, output a new result image \( I&#39; = I / s \) . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>The input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td>The input scalar </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar2</td><td>For a color image to specify the scalar value used for the 2nd channel<br  />
If both <em>scalar2</em> and <em>scalar3</em> is set to 0 (default), we'll use the value <em>scalar</em> for all 3 channels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar3</td><td>For a color image to specify the scalar value used for the 3rd channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#aa0a28d791687c074c41b9c44d43bf858">Divide()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.8.0 </dd></dl>

</div>
</div>
<a id="a69163617efcc3e863d467bc147af34e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69163617efcc3e863d467bc147af34e4">&#9670;&nbsp;</a></span>Flip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Flip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_l_p_v_core_lib.html#aca29028958a911e3c81e54458680682f">LPVFlipType</a>&#160;</td>
          <td class="paramname"><em>flipType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flip an image horizontally or/and vertically.<br  />
If the pass-in result image object is empty, then we'll use the same size as the input. Otherwise, the original size is kept and the border pixels are filled with background color(default to black). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>The input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flipType</td><td>The type of flip </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image Otherwise, the original size is kept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e2fdb50ded7f6231c8a2cf2a655bb66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e2fdb50ded7f6231c8a2cf2a655bb66">&#9670;&nbsp;</a></span>GainOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GainOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale an image with the given gain value, then add the given offset value, \( I&#39; = I * gain + offset \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>The input image </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gain</td><td>The gain value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The offset value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a009217aa93d3f41dfdf5a3c070264aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a009217aa93d3f41dfdf5a3c070264aab">&#9670;&nbsp;</a></span>Invert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Invert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invert an image, \( I&#39; = 255 - I \) for 8bit images, and \( I&#39; = 65535 - I \) for 16bit images. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>The input image </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a5dd391126a76472eca8379e53cdf4e59">BitNot()</a> </dd></dl>

</div>
</div>
<a id="a09fb50f951e9df17d7243b6e7db56a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09fb50f951e9df17d7243b6e7db56a9c">&#9670;&nbsp;</a></span>Log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the logarithm of the input image pixel by pixel, output a new result image, \( I&#39; = \log_{base}{I} \) . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>The input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>The input base, should be a positive value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7c79b8eb70dff2f1169d0a06db7bad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7c79b8eb70dff2f1169d0a06db7bad1">&#9670;&nbsp;</a></span>Max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the maximum of the two input images pixel by pixel, output a new result image \( I&#39; = \max (I_{1}, I_{2}) \) . \nThe two input image should have the same size and format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img1</td><td>The first input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">img2</td><td>The second input image </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a41fbc595b7b5936b45263e9ae1e1cef6">MaxScalar()</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#afca3e1de386b0ff5fb6fad7fd3a54d2d">Min()</a> </dd></dl>

</div>
</div>
<a id="a41fbc595b7b5936b45263e9ae1e1cef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41fbc595b7b5936b45263e9ae1e1cef6">&#9670;&nbsp;</a></span>MaxScalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MaxScalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the maximum of the input images and a scalar value pixel by pixel, output a new result image \( I&#39; = \max (I, s) \) . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>The input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td>The input scalar </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar2</td><td>For a color image to specify the scalar value used for the 2nd channel<br  />
If both <em>scalar2</em> and <em>scalar3</em> is set to 0 (default), we'll use the value <em>scalar</em> for all 3 channels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar3</td><td>For a color image to specify the scalar value used for the 3rd channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#afca3e1de386b0ff5fb6fad7fd3a54d2d">Min()</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#ae7c79b8eb70dff2f1169d0a06db7bad1">Max()</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a62830872fac430e8737587ca026557d2">MinScalar()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.8.0 </dd></dl>

</div>
</div>
<a id="afca3e1de386b0ff5fb6fad7fd3a54d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca3e1de386b0ff5fb6fad7fd3a54d2d">&#9670;&nbsp;</a></span>Min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the minimum of the two input images pixel by pixel, output a new result image \( I&#39; = \min (I_{1}, I_{2}) \) . \nThe two input image should have the same size and format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img1</td><td>The first input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">img2</td><td>The second input image </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a62830872fac430e8737587ca026557d2">MinScalar()</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#ae7c79b8eb70dff2f1169d0a06db7bad1">Max()</a> </dd></dl>

</div>
</div>
<a id="a62830872fac430e8737587ca026557d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62830872fac430e8737587ca026557d2">&#9670;&nbsp;</a></span>MinScalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MinScalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the minimum of the input images and a scalar value pixel by pixel, output a new result image \( I&#39; = \min (I, s \))} . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>The input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td>The input scalar </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar2</td><td>For a color image to specify the scalar value used for the 2nd channel<br  />
If both <em>scalar2</em> and <em>scalar3</em> is set to 0 (default), we'll use the value <em>scalar</em> for all 3 channels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar3</td><td>For a color image to specify the scalar value used for the 3rd channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#afca3e1de386b0ff5fb6fad7fd3a54d2d">Min()</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#ae7c79b8eb70dff2f1169d0a06db7bad1">Max()</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a41fbc595b7b5936b45263e9ae1e1cef6">MaxScalar()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.8.0 </dd></dl>

</div>
</div>
<a id="aa24a05c09037b92bf79e964ac8118c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa24a05c09037b92bf79e964ac8118c56">&#9670;&nbsp;</a></span>Multiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply the two input images pixel by pixel, output a new result image \( I&#39; = I_{1} \cdot I_{2} \) . \nThe two input image should have the same size and format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img1</td><td>The first input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">img2</td><td>The second input image </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a9c1b15c7aadd849832317e466164e5fc">MultiplyScalar()</a> </dd></dl>

</div>
</div>
<a id="a9c1b15c7aadd849832317e466164e5fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c1b15c7aadd849832317e466164e5fc">&#9670;&nbsp;</a></span>MultiplyScalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MultiplyScalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply the input images and a scalar value pixel by pixel, output a new result image \( I&#39; = I \cdot s \) . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>The input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td>The input scalar </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar2</td><td>For a color image to specify the scalar value used for the 2nd channel<br  />
If both <em>scalar2</em> and <em>scalar3</em> is set to 0 (default), we'll use the value <em>scalar</em> for all 3 channels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar3</td><td>For a color image to specify the scalar value used for the 3rd channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#aa24a05c09037b92bf79e964ac8118c56">Multiply()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.8.0 </dd></dl>

</div>
</div>
<a id="adf660a10ca16161030619866f2b49e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf660a10ca16161030619866f2b49e55">&#9670;&nbsp;</a></span>Normalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Normalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>resultImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fromMinValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fromMaxValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>toMinValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>toMaxValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>belowMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>aboveMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Normalize the given image, stretching the values between the given minimum and maximum value to the target range. The image depth is not changed, the output image has the same depth and channels as the input. For a multi-channel color image, it outputs a color image and each channel is normalized on its own. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>The input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fromMinValue,fromMaxValue</td><td>The specified value of interest. Pass in empty range (0, 0) to use the minimum / maximum of current image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">toMinValue,toMaxValue</td><td>The target value range. Pass in empty range (0, 0) to use theoretical value range based on image depth, aka. 0 ~ 255 for 8bit images, 0 ~ 65536 for 16bit images. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultImg</td><td>Output the normalized image </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">belowMask,aboveMask</td><td><img src="color_binary.png" alt="" class="inline" title="Binary"/> <img src="bit8.png" alt="" class="inline" title="8 Bit"/> Output the mask for pixels out of range of interest. White pixels are those below <code>fromMinValue</code> or above <code>fromMaxValue</code> . You may then fill those pixels to black or target minimum / maximum values, or patch via <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_filter.html#a7323d90a89ea3ec6583a3d7855306cb3">FillHole()</a>. It's optional, pass in null if unnecessary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>2.11.0 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#aa2263e543b518236ba5126bb4888e2b0">NormalizeMeanStdDev()</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_convert.html#a401acc2200aef341efed608a1b785fc4">NormalizeTo8()</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_convert.html#a28f8d473acce8d3b2cddc3fe4b02d852">NormalizeTo16()</a> </dd></dl>

</div>
</div>
<a id="aa2263e543b518236ba5126bb4888e2b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2263e543b518236ba5126bb4888e2b0">&#9670;&nbsp;</a></span>NormalizeMeanStdDev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NormalizeMeanStdDev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>resultImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>toMinValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>toMaxValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>belowMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>aboveMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Normalize the given image based on its current mean and standard derivation, stretching the range \( (Mean - k1 \times StdDev, Mean + k2 \times StdDev) \) to target range. The image depth is not changed, the output image has the same depth and channels as the input. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>The input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k1</td><td>The factor revised to the lower bound formed by mean and standard derivation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k2</td><td>The factor revised to the upper bound formed by mean and standard derivation. Pass in negative value to use same factor as <code>k1</code> . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">toMinValue,toMaxValue</td><td>The target value range. Pass in empty range (0, 0) to use theoretical value range based on image depth, aka. 0 ~ 255 for 8bit images, 0 ~ 65536 for 16bit images. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultImg</td><td>Output the normalized image </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">belowMask,aboveMask</td><td><img src="color_binary.png" alt="" class="inline" title="Binary"/> <img src="bit8.png" alt="" class="inline" title="8 Bit"/> Output the mask for pixels out of range of interest. White pixels are those below <code>fromMinValue</code> or above <code>fromMaxValue</code> . You may then fill those pixels to black or target minimum / maximum values, or patch via FillHole(). It's optional, pass in null if unnecessary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>2.11.0 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#aa2263e543b518236ba5126bb4888e2b0">NormalizeMeanStdDev()</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_convert.html#a401acc2200aef341efed608a1b785fc4">NormalizeTo8()</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_convert.html#a28f8d473acce8d3b2cddc3fe4b02d852">NormalizeTo16()</a> </dd></dl>

</div>
</div>
<a id="af51684082a5ca31d6db24aba6be294b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af51684082a5ca31d6db24aba6be294b3">&#9670;&nbsp;</a></span>Pow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Pow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>power</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the power(exponentiation) of the input image pixel by pixel, output a new result image, \( I&#39; = I^{power} \) . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>The input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">power</td><td>The input exponent or power </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc1501a3fbcf6b7f741134d9af0ceef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1501a3fbcf6b7f741134d9af0ceef9">&#9670;&nbsp;</a></span>ProjectX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_array.html">LArray</a>&lt;double&gt; ProjectX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_l_p_v_core_lib.html#a044b4c1019ab24bd62eed3e7fd764b85">LPVAggregation</a>&#160;</td>
          <td class="paramname"><em>aggType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Projects an image horizontally, aggregating pixels on each row </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td><img src="color_gray.png" alt="" class="inline" title="Grayscale"/> <img src="bit8.png" alt="" class="inline" title="8 Bit"/> The input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aggType</td><td>The aggregation method used for projection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">result</td><td>Return the projection result vector, it's a list of double values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8af52d9cf013941f00b02e54831c8dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af52d9cf013941f00b02e54831c8dec">&#9670;&nbsp;</a></span>ProjectY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_array.html">LArray</a>&lt;double&gt; ProjectY </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_l_p_v_core_lib.html#a044b4c1019ab24bd62eed3e7fd764b85">LPVAggregation</a>&#160;</td>
          <td class="paramname"><em>aggType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Projects an image vertically, aggregating pixels on each column </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td><img src="color_gray.png" alt="" class="inline" title="Grayscale"/> <img src="bit8.png" alt="" class="inline" title="8 Bit"/> The input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aggType</td><td>The aggregation method used for projection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">result</td><td>Return the projection result vector, it's a list of double values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b035d4123952719d670e3f9072029b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b035d4123952719d670e3f9072029b8">&#9670;&nbsp;</a></span>Resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>zoomX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>zoomY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_l_p_v_core_lib.html#a8994f6c3a4ba4e0d0e9a8eb78ac86c92">LPVInterpolationMethod</a>&#160;</td>
          <td class="paramname"><em>interMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resize an image by the given scale factor, using the image center as the pivot point.<br  />
If the pass-in result image object is empty, then we'll use the same size as the input. Otherwise, the original size is kept and the border pixels are filled with background color(default to black). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>The input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zoomX</td><td>Factor for zooming in or out in the x-coordinate direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zoomY</td><td>Factor for zooming in or out in the y-coordinate direction. Setting to 0 means same zoom factor as zoomX, aka. isotropic scaling. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interMethod</td><td>The interpolation method used in resizing </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a3d23a653d5816ffbb6089950840fa5c5">ResizeTo()</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a5a2cd12aabad596e032548b18af31928">Rotate()</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a63734a869140124d46e534ec5fbadde3">ScaleRotate()</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a1f47cc18862bd892bae73e722c9443d4">Transform()</a> </dd></dl>

</div>
</div>
<a id="a3d23a653d5816ffbb6089950840fa5c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d23a653d5816ffbb6089950840fa5c5">&#9670;&nbsp;</a></span>ResizeTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ResizeTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_l_p_v_core_lib.html#a8994f6c3a4ba4e0d0e9a8eb78ac86c92">LPVInterpolationMethod</a>&#160;</td>
          <td class="paramname"><em>interMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resize an image to the given new size.<br  />
If the pass-in result image object is empty, then we'll use the same size as the input. Otherwise, the original size is kept and the border pixels are filled with background color(default to black). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>The input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>The width of the new size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>The height of the new size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interMethod</td><td>The interpolation method used in resizing </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a2b035d4123952719d670e3f9072029b8">Resize()</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a5a2cd12aabad596e032548b18af31928">Rotate()</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a63734a869140124d46e534ec5fbadde3">ScaleRotate()</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a1f47cc18862bd892bae73e722c9443d4">Transform()</a> </dd></dl>

</div>
</div>
<a id="a5a2cd12aabad596e032548b18af31928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a2cd12aabad596e032548b18af31928">&#9670;&nbsp;</a></span>Rotate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_l_p_v_core_lib.html#a8994f6c3a4ba4e0d0e9a8eb78ac86c92">LPVInterpolationMethod</a>&#160;</td>
          <td class="paramname"><em>interMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rotate an image by the given degree clockwise, using the image center as the pivot point.<br  />
If the pass-in result image object is empty, then we'll use the same size as the input. Otherwise, the original size is kept and the border pixels are filled with background color(default to black). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>The input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle</td><td>The rotation angle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interMethod</td><td>The interpolation method used in rotation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a63734a869140124d46e534ec5fbadde3">ScaleRotate()</a> </dd></dl>

</div>
</div>
<a id="a63734a869140124d46e534ec5fbadde3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63734a869140124d46e534ec5fbadde3">&#9670;&nbsp;</a></span>ScaleRotate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ScaleRotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>zoomX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>zoomY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pivotImgX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pivotImgY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pivotResultX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pivotResultY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_l_p_v_core_lib.html#a8994f6c3a4ba4e0d0e9a8eb78ac86c92">LPVInterpolationMethod</a>&#160;</td>
          <td class="paramname"><em>interMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale and rotate an image, using the user-defined pivot points.<br  />
If the pass-in result image object is empty, then we'll use the same size as the input. Otherwise, the original size is kept and the border pixels are filled with background color(default to black). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>The input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle</td><td>The clockwise rotation angle in degrees </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zoomX</td><td>Factor for zooming in or out in the x-coordinate direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zoomY</td><td>Factor for zooming in or out in the y-coordinate direction. Setting to 0 means same zoom factor as zoomX, aka. isotropic scaling. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pivotImgX</td><td>The x-coordinate of the pivot point on the input image. The pivot point is used as the center of the scale and rotation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pivotImgY</td><td>The y-coordinate of the pivot point on the input image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pivotResultX</td><td>The x-coordinate of the pivot point on the result image. It's the "same" pixel as the pivot point in the input image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pivotResultY</td><td>The y-coordinate of the pivot point on the result image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interMethod</td><td>The interpolation method used in resizing </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a3d23a653d5816ffbb6089950840fa5c5">ResizeTo()</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a5a2cd12aabad596e032548b18af31928">Rotate()</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a63734a869140124d46e534ec5fbadde3">ScaleRotate()</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a1f47cc18862bd892bae73e722c9443d4">Transform()</a> </dd></dl>

</div>
</div>
<a id="aafee0b4602b5dea5c473185cd2976be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafee0b4602b5dea5c473185cd2976be3">&#9670;&nbsp;</a></span>Split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xStep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>yCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>yStep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ySpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image_list.html">ILImageList</a> *&#160;</td>
          <td class="paramname"><em>resultList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>cyclicMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>sameSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split a image into a grid of several images. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>The input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xCount,yCount</td><td>Specify the split count in column / row </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xStep,yStep</td><td>The column / row step for individual split. For non cyclical mode, this should be the width / height of the result images. While for cyclical mode, we collect those count column / row in each cycle to form the final results. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xSpace,ySpace</td><td>The space between split in column / row </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cyclicMode</td><td>Whether to enable cyclical mode, which will cyclically repeat the splitting until the entire image is processed. Individual splitting results are merged together as the final results. By default, it's true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sameSize</td><td>Whether to make sure all result images have the same size. The undefined pixels are filled with background color. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Output the result images' collection row by row from top to bottom then from left to right. </td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Example</dt>
<dd>SplitImage.cpp/cs</dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#ad8ea99043d2749a8f013eb7d92583fd6">SplitX()</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a0d94a20c6f7bef41956747a5c3c6a04e">SplitY()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.10.0 </dd></dl>

</div>
</div>
<a id="ad8ea99043d2749a8f013eb7d92583fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ea99043d2749a8f013eb7d92583fd6">&#9670;&nbsp;</a></span>SplitX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SplitX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image_list.html">ILImageList</a> *&#160;</td>
          <td class="paramname"><em>resultList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>cyclicMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>sameSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split a image horizontally into several images. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>The input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Specify the split count </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">step</td><td>The column step for individual split. For non cyclical mode, this should be the width of the result images. While for cyclical mode, we collect those count columns in each cycle to form the final results. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>The space between split </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cyclicMode</td><td>Whether to enable cyclical mode, which will cyclically repeat the splitting until the entire image is processed. Individual splitting results are merged together as the final results. By default, it's true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sameSize</td><td>Whether to make sure all result images have the same size. The undefined pixels are filled with background color. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Output the result images' collection from left to right </td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Example</dt>
<dd>SplitImage.cpp/cs</dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a0d94a20c6f7bef41956747a5c3c6a04e">SplitY()</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#aafee0b4602b5dea5c473185cd2976be3">Split()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.10.0 </dd></dl>

</div>
</div>
<a id="a0d94a20c6f7bef41956747a5c3c6a04e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d94a20c6f7bef41956747a5c3c6a04e">&#9670;&nbsp;</a></span>SplitY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SplitY </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image_list.html">ILImageList</a> *&#160;</td>
          <td class="paramname"><em>resultList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>cyclicMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>sameSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split a image vertically into several images. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>The input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Specify the split count </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">step</td><td>The row step for individual split. For non cyclical mode, this should be the height of the result images. While for cyclical mode, we collect those count rows in each cycle to form the final results. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">space</td><td>The space between split </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cyclicMode</td><td>Whether to enable cyclical mode, which will cyclically repeat the splitting until the entire image is processed. Individual splitting results are merged together as the final results. By default, it's true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sameSize</td><td>Whether to make sure all result images have the same size. The undefined pixels are filled with background color. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Output the result images' collection from top to bottom </td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Example</dt>
<dd>SplitImage.cpp/cs</dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#ad8ea99043d2749a8f013eb7d92583fd6">SplitX()</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#aafee0b4602b5dea5c473185cd2976be3">Split()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.10.0 </dd></dl>

</div>
</div>
<a id="a6aa20ebb5264ac83616ce57a100a7da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa20ebb5264ac83616ce57a100a7da0">&#9670;&nbsp;</a></span>Sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtract two input images pixel by pixel, output a new result image \( I&#39; = I_{1} - I_{2} \) . \nThe two input image should have the same size and format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img1</td><td>The first input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">img2</td><td>The second input image </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a4bb349dc5aeaadaacfcefde3fb283eaf">SubScalar()</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a94ce706b860d77991b5447d74ab7a6ca">Diff()</a> </dd></dl>

</div>
</div>
<a id="a4bb349dc5aeaadaacfcefde3fb283eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bb349dc5aeaadaacfcefde3fb283eaf">&#9670;&nbsp;</a></span>SubScalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SubScalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtract a scalar value from the input images pixel by pixel, output a new result image \( I&#39; = I - s \) . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>The input image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td>The input scalar </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar2</td><td>For a color image to specify the scalar value used for the 2nd channel<br  />
If both <em>scalar2</em> and <em>scalar3</em> is set to 0 (default), we'll use the value <em>scalar</em> for all 3 channels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar3</td><td>For a color image to specify the scalar value used for the 3rd channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a6aa20ebb5264ac83616ce57a100a7da0">Sub()</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a882103f487fab90873697dcecc268dc8">DiffScalar()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.8.0 </dd></dl>

</div>
</div>
<a id="a102798855741d439b8903234884713a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a102798855741d439b8903234884713a8">&#9670;&nbsp;</a></span>TileX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TileX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image_list.html">ILImageList</a> *&#160;</td>
          <td class="paramname"><em>imgList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>columnCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>compactMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tile a list of images into a large image horizontally. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">imgList</td><td>The input image list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">columnCount</td><td>The number of images in one row. Pass in 0 or negative value to tile into one line.<br  />
If the total count of the inputs is not a multiple of the specified column count, the last row are filled with background color. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compactMode</td><td>In compact mode(True), images of different sizes in a horizontal row are copied contiguously. Otherwise(False), result size is determined by the maximum width and height, and the smaller images are copied to the center of the respective tile. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Output the result image. </td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Example</dt>
<dd>TileImage.cpp/cs</dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a4ee13ea45a863b3805c6d711be3b9672">TileY()</a> </dd></dl>

</div>
</div>
<a id="a4ee13ea45a863b3805c6d711be3b9672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ee13ea45a863b3805c6d711be3b9672">&#9670;&nbsp;</a></span>TileY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TileY </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image_list.html">ILImageList</a> *&#160;</td>
          <td class="paramname"><em>imgList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rowCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>compactMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tile a list of images into a large image vertically. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">imgList</td><td>The input image list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowCount</td><td>The number of images in one column. Pass in 0 or negative value to tile into one line.<br  />
If the total count of the inputs is not a multiple of the specified row count, the last column are filled with background color. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compactMode</td><td>In compact mode(True), images of different sizes in a vertical column are copied contiguously. Otherwise(False), result size is determined by the maximum width and height, and the smaller images are copied to the center of the respective tile. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Output the result image. </td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Example</dt>
<dd>TileImage.cpp/cs</dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a102798855741d439b8903234884713a8">TileX()</a> </dd></dl>

</div>
</div>
<a id="a1f47cc18862bd892bae73e722c9443d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f47cc18862bd892bae73e722c9443d4">&#9670;&nbsp;</a></span>Transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_geom_lib_1_1_i_l_transform.html">ILTransform</a> *&#160;</td>
          <td class="paramname"><em>tf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_l_p_v_core_lib.html#a8994f6c3a4ba4e0d0e9a8eb78ac86c92">LPVInterpolationMethod</a>&#160;</td>
          <td class="paramname"><em>interMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_l_p_v_core_lib_1_1_i_l_image.html">ILImage</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transform the image via the given transformation and return a new image.<br  />
If the pass-in result image object is empty, then we'll use the same size as the input. Otherwise, the original size is kept and the border pixels are filled with background color(default to black). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">img</td><td>The input image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tf</td><td>The transformation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interMethod</td><td>The interpolation method used in resizing </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Return result image. </td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Example</dt>
<dd>LinearTransform.cpp/cs</dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a2b035d4123952719d670e3f9072029b8">Resize()</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a3d23a653d5816ffbb6089950840fa5c5">ResizeTo()</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a5a2cd12aabad596e032548b18af31928">Rotate()</a>, <a class="el" href="interface_l_p_v_img_proc_lib_1_1_i_l_image_op.html#a63734a869140124d46e534ec5fbadde3">ScaleRotate()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
 2024 <a href="http://www.hzleaper.com/">Hangzhou Leaper Tech. Ltd.</a>
</small></address>
<script type="text/javascript">
//<![CDATA[
addTutorialsButtons();
var cn_btn = document.getElementById("cn_btn");
cn_btn.addEventListener("click", function(){window.location.href = window.location.href.replace("/en/", "/cn/");});
var en_btn = document.getElementById("en_btn");
en_btn.addEventListener("click", function(){window.location.href = window.location.href.replace("/cn/", "/en/");});
//]]>
</script>
</body>
</html>
